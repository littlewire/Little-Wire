
AVRASM ver. 2.1.43  C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\BOOTLOAD.ASM Sun Dec 18 13:53:33 2011

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\AVR Studio 5.0\avrassembler\include\tn85def.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\BOOTLOAD.ASM(19): Including file 'C:\Program Files (x86)\Atmel\AVR Studio 5.0\avrassembler\include\tn85def.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\BOOTLOAD.ASM(64): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.inc(8): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.h'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.h(2): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\compat.h'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.h(3): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\protocol.h'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.inc(23): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\watchdog.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.inc(32): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\abaud.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.inc(33): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\password.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.inc(45): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\command.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\command.inc(68): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\message.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\command.inc(71): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\verify.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\command.inc(77): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\progtiny.inc'
C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\fastload.inc(46): Including file 'C:\Users\kehribar\Documents\AVRStudio\myBootLoader\myBootLoader\uart.inc'
                 
                 ;*************************************************************************
                 
                 ;***** Created: 2011-02-09 12:04 ******* Source: ATtiny85.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn85def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny85
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny85
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN85DEF_INC_
                 #define _TN85DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny85
                 #pragma AVRPART ADMIN PART_NAME ATtiny85
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x93
                 .equ	SIGNATURE_002	= 0x0b
                 
                 #pragma AVRPART CORE CORE_VERSION V2
                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	GIMSK	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCSR	= 0x37
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	TCCR0B	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	TCCR1	= 0x30
                 .equ	TCNT1	= 0x2f
                 .equ	OCR1A	= 0x2e
                 .equ	OCR1C	= 0x2d
                 .equ	GTCCR	= 0x2c
                 .equ	OCR1B	= 0x2b
                 .equ	TCCR0A	= 0x2a
                 .equ	OCR0A	= 0x29
                 .equ	OCR0B	= 0x28
                 .equ	PLLCSR	= 0x27
                 .equ	CLKPR	= 0x26
                 .equ	DT1A	= 0x25
                 .equ	DT1B	= 0x24
                 .equ	DTPS	= 0x23
                 .equ	DWDR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	PRR	= 0x20
                 .equ	EEARH	= 0x1f
                 .equ	EEARL	= 0x1e
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PCMSK	= 0x15
                 .equ	DIDR0	= 0x14
                 .equ	GPIOR2	= 0x13
                 .equ	GPIOR1	= 0x12
                 .equ	GPIOR0	= 0x11
                 .equ	USIBR	= 0x10
                 .equ	USIDR	= 0x0f
                 .equ	USISR	= 0x0e
                 .equ	USICR	= 0x0d
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	ADCSRB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** PORTB ************************
                 ; PORTB - Data Register, Port B
                 .equ	PORTB0	= 0	; 
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; 
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; 
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; 
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; 
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; 
                 .equ	PB5	= 5	; For compatibility
                 
                 ; DDRB - Data Direction Register, Port B
                 .equ	DDB0	= 0	; 
                 .equ	DDB1	= 1	; 
                 .equ	DDB2	= 2	; 
                 .equ	DDB3	= 3	; 
                 .equ	DDB4	= 4	; 
                 .equ	DDB5	= 5	; 
                 
                 ; PINB - Input Pins, Port B
                 .equ	PINB0	= 0	; 
                 .equ	PINB1	= 1	; 
                 .equ	PINB2	= 2	; 
                 .equ	PINB3	= 3	; 
                 .equ	PINB4	= 4	; 
                 .equ	PINB5	= 5	; 
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	AINBG	= ACBG	; For compatibility
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR0 - 
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	REFS2	= 4	; Reference Selection Bit 2
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                 .equ	IPR	= 5	; Input Polarity Mode
                 .equ	BIN	= 7	; Bipolar Input Mode
                 
                 ; DIDR0 - Digital Input Disable Register 0
                 .equ	ADC1D	= 2	; ADC1 Digital input Disable
                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                 
                 
                 ; ***** USI **************************
                 ; USIBR - USI Buffer Register
                 .equ	USIBR0	= 0	; USI Buffer Register bit 0
                 .equ	USIBR1	= 1	; USI Buffer Register bit 1
                 .equ	USIBR2	= 2	; USI Buffer Register bit 2
                 .equ	USIBR3	= 3	; USI Buffer Register bit 3
                 .equ	USIBR4	= 4	; USI Buffer Register bit 4
                 .equ	USIBR5	= 5	; USI Buffer Register bit 5
                 .equ	USIBR6	= 6	; USI Buffer Register bit 6
                 .equ	USIBR7	= 7	; USI Buffer Register bit 7
                 
                 ; USIDR - USI Data Register
                 .equ	USIDR0	= 0	; USI Data Register bit 0
                 .equ	USIDR1	= 1	; USI Data Register bit 1
                 .equ	USIDR2	= 2	; USI Data Register bit 2
                 .equ	USIDR3	= 3	; USI Data Register bit 3
                 .equ	USIDR4	= 4	; USI Data Register bit 4
                 .equ	USIDR5	= 5	; USI Data Register bit 5
                 .equ	USIDR6	= 6	; USI Data Register bit 6
                 .equ	USIDR7	= 7	; USI Data Register bit 7
                 
                 ; USISR - USI Status Register
                 .equ	USICNT0	= 0	; USI Counter Value Bit 0
                 .equ	USICNT1	= 1	; USI Counter Value Bit 1
                 .equ	USICNT2	= 2	; USI Counter Value Bit 2
                 .equ	USICNT3	= 3	; USI Counter Value Bit 3
                 .equ	USIDC	= 4	; Data Output Collision
                 .equ	USIPF	= 5	; Stop Condition Flag
                 .equ	USIOIF	= 6	; Counter Overflow Interrupt Flag
                 .equ	USISIF	= 7	; Start Condition Interrupt Flag
                 
                 ; USICR - USI Control Register
                 .equ	USITC	= 0	; Toggle Clock Port Pin
                 .equ	USICLK	= 1	; Clock Strobe
                 .equ	USICS0	= 2	; USI Clock Source Select Bit 0
                 .equ	USICS1	= 3	; USI Clock Source Select Bit 1
                 .equ	USIWM0	= 4	; USI Wire Mode Bit 0
                 .equ	USIWM1	= 5	; USI Wire Mode Bit 1
                 .equ	USIOIE	= 6	; Counter Overflow Interrupt Enable
                 .equ	USISIE	= 7	; Start Condition Interrupt Enable
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 
                 ; GIMSK - General Interrupt Mask Register
                 .equ	GICR	= GIMSK	; For compatibility
                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 
                 ; GIFR - General Interrupt Flag register
                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 
                 ; PCMSK - Pin Change Enable Mask
                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEARL - EEPROM Address Register Low Byte
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                 
                 ; EEARH - EEPROM Address Register High Byte
                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 0
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEPE	= 1	; EEPROM Write Enable
                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDTCSR	= WDTCR	; For compatibility
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDTOE	= WDCE	; For compatibility
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 .equ	OCIE0A	= 4	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 
                 ; TIFR - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                 .equ	OCF0A	= 4	; Timer/Counter0 Output Compare Flag 0A
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; 
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 ;.equ	OCR0_0	= 0	; 
                 ;.equ	OCR0_1	= 1	; 
                 ;.equ	OCR0_2	= 2	; 
                 ;.equ	OCR0_3	= 3	; 
                 ;.equ	OCR0_4	= 4	; 
                 ;.equ	OCR0_5	= 5	; 
                 ;.equ	OCR0_6	= 6	; 
                 ;.equ	OCR0_7	= 7	; 
                 
                 ; GTCCR - General Timer/Counter Control Register
                 .equ	PSR0	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TCCR1 - Timer/Counter Control Register
                 .equ	CS10	= 0	; Clock Select Bits
                 .equ	CS11	= 1	; Clock Select Bits
                 .equ	CS12	= 2	; Clock Select Bits
                 .equ	CS13	= 3	; Clock Select Bits
                 .equ	COM1A0	= 4	; Compare Output Mode, Bit 1
                 .equ	COM1A1	= 5	; Compare Output Mode, Bit 0
                 .equ	PWM1A	= 6	; Pulse Width Modulator Enable
                 .equ	CTC1	= 7	; Clear Timer/Counter on Compare Match
                 
                 ; TCNT1 - Timer/Counter Register
                 .equ	TCNT1_0	= 0	; Timer/Counter Register Bit 0
                 .equ	TCNT1_1	= 1	; Timer/Counter Register Bit 1
                 .equ	TCNT1_2	= 2	; Timer/Counter Register Bit 2
                 .equ	TCNT1_3	= 3	; Timer/Counter Register Bit 3
                 .equ	TCNT1_4	= 4	; Timer/Counter Register Bit 4
                 .equ	TCNT1_5	= 5	; Timer/Counter Register Bit 5
                 .equ	TCNT1_6	= 6	; Timer/Counter Register Bit 6
                 .equ	TCNT1_7	= 7	; Timer/Counter Register Bit 7
                 
                 ; OCR1A - Output Compare Register
                 .equ	OCR1A0	= 0	; Output Compare Register A Bit 0
                 .equ	OCR1A1	= 1	; Output Compare Register A Bit 1
                 .equ	OCR1A2	= 2	; Output Compare Register A Bit 2
                 .equ	OCR1A3	= 3	; Output Compare Register A Bit 3
                 .equ	OCR1A4	= 4	; Output Compare Register A Bit 4
                 .equ	OCR1A5	= 5	; Output Compare Register A Bit 5
                 .equ	OCR1A6	= 6	; Output Compare Register A Bit 6
                 .equ	OCR1A7	= 7	; Output Compare Register A Bit 7
                 
                 ; OCR1B - Output Compare Register
                 .equ	OCR1B0	= 0	; Output Compare Register B Bit 0
                 .equ	OCR1B1	= 1	; Output Compare Register B Bit 1
                 .equ	OCR1B2	= 2	; Output Compare Register B Bit 2
                 .equ	OCR1B3	= 3	; Output Compare Register B Bit 3
                 .equ	OCR1B4	= 4	; Output Compare Register B Bit 4
                 .equ	OCR1B5	= 5	; Output Compare Register B Bit 5
                 .equ	OCR1B6	= 6	; Output Compare Register B Bit 6
                 .equ	OCR1B7	= 7	; Output Compare Register B Bit 7
                 
                 ; OCR1C - Output compare register
                 .equ	OCR1C0	= 0	; 
                 .equ	OCR1C1	= 1	; 
                 .equ	OCR1C2	= 2	; 
                 .equ	OCR1C3	= 3	; 
                 .equ	OCR1C4	= 4	; 
                 .equ	OCR1C5	= 5	; 
                 .equ	OCR1C6	= 6	; 
                 .equ	OCR1C7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 5	; OCIE1A: Timer/Counter1 Output Compare B Interrupt Enable
                 .equ	OCIE1A	= 6	; OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 5	; Timer/Counter1 Output Compare Flag 1B
                 .equ	OCF1A	= 6	; Timer/Counter1 Output Compare Flag 1A
                 
                 ; GTCCR - Timer counter control register
                 .equ	PSR1	= 1	; Prescaler Reset Timer/Counter1
                 .equ	FOC1A	= 2	; Force Output Compare 1A
                 .equ	FOC1B	= 3	; Force Output Compare Match 1B
                 .equ	COM1B0	= 4	; Comparator B Output Mode
                 .equ	COM1B1	= 5	; Comparator B Output Mode
                 .equ	PWM1B	= 6	; Pulse Width Modulator B Enable
                 
                 ; DTPS - Dead time prescaler register
                 .equ	DTPS0	= 0	; 
                 .equ	DTPS1	= 1	; 
                 
                 ; DT1A - Dead time value register
                 .equ	DTVL0	= 0	; 
                 .equ	DTVL1	= 1	; 
                 .equ	DTVL2	= 2	; 
                 .equ	DTVL3	= 3	; 
                 .equ	DTVH0	= 4	; 
                 .equ	DTVH1	= 5	; 
                 .equ	DTVH2	= 6	; 
                 .equ	DTVH3	= 7	; 
                 
                 ; DT1B - Dead time value B
                 ;.equ	DTVL0	= 0	; 
                 ;.equ	DTVL1	= 1	; 
                 ;.equ	DTVL2	= 2	; 
                 ;.equ	DTVL3	= 3	; 
                 ;.equ	DTVH0	= 4	; 
                 ;.equ	DTVH1	= 5	; 
                 ;.equ	DTVH2	= 6	; 
                 ;.equ	DTVH3	= 7	; 
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCSR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	RFLB	= 3	; Read fuse and lock bits
                 .equ	CTPB	= 4	; Clear temporary page buffer
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                 .equ	SE	= 5	; Sleep Enable
                 .equ	PUD	= 6	; Pull-up Disable
                 
                 ; MCUSR - MCU Status register
                 .equ	PORF	= 0	; Power-On Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; PRR - Power Reduction Register
                 .equ	PRADC	= 0	; Power Reduction ADC
                 .equ	PRUSI	= 1	; Power Reduction USI
                 .equ	PRTIM0	= 2	; Power Reduction Timer/Counter0
                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                 
                 ; OSCCAL - Oscillator Calibration Register
                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                 .equ	CAL7	= 7	; Oscillatro Calibration Value Bit 7
                 
                 ; PLLCSR - PLL Control and status register
                 .equ	PLOCK	= 0	; PLL Lock detector
                 .equ	PLLE	= 1	; PLL Enable
                 .equ	PCKE	= 2	; PCK Enable
                 .equ	LSM	= 7	; Low speed mode
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; DWDR - debugWire data register
                 .equ	DWDR0	= 0	; 
                 .equ	DWDR1	= 1	; 
                 .equ	DWDR2	= 2	; 
                 .equ	DWDR3	= 3	; 
                 .equ	DWDR4	= 4	; 
                 .equ	DWDR5	= 5	; 
                 .equ	DWDR6	= 6	; 
                 .equ	DWDR7	= 7	; 
                 
                 ; GPIOR2 - General Purpose IO register 2
                 .equ	GPIOR20	= 0	; 
                 .equ	GPIOR21	= 1	; 
                 .equ	GPIOR22	= 2	; 
                 .equ	GPIOR23	= 3	; 
                 .equ	GPIOR24	= 4	; 
                 .equ	GPIOR25	= 5	; 
                 .equ	GPIOR26	= 6	; 
                 .equ	GPIOR27	= 7	; 
                 
                 ; GPIOR1 - General Purpose register 1
                 .equ	GPIOR10	= 0	; 
                 .equ	GPIOR11	= 1	; 
                 .equ	GPIOR12	= 2	; 
                 .equ	GPIOR13	= 3	; 
                 .equ	GPIOR14	= 4	; 
                 .equ	GPIOR15	= 5	; 
                 .equ	GPIOR16	= 6	; 
                 .equ	GPIOR17	= 7	; 
                 
                 ; GPIOR0 - General purpose register 0
                 .equ	GPIOR00	= 0	; 
                 .equ	GPIOR01	= 1	; 
                 .equ	GPIOR02	= 2	; 
                 .equ	GPIOR03	= 3	; 
                 .equ	GPIOR04	= 4	; 
                 .equ	GPIOR05	= 5	; 
                 .equ	GPIOR06	= 6	; 
                 .equ	GPIOR07	= 7	; 
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock source
                 .equ	CKSEL1	= 1	; Select Clock source
                 .equ	CKSEL2	= 2	; Select Clock source
                 .equ	CKSEL3	= 3	; Select Clock source
                 .equ	SUT0	= 4	; Select start-up time
                 .equ	SUT1	= 5	; Select start-up time
                 .equ	CKOUT	= 6	; Clock Output Enable
                 .equ	CKDIV8	= 7	; Divide clock by 8
                 
                 ; HIGH fuse bits
                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through the Chip Erase
                 .equ	WDTON	= 4	; Watchdog Timer always on
                 .equ	SPIEN	= 5	; Enable Serial Program and Data Downloading
                 .equ	DWEN	= 6	; DebugWIRE Enable
                 .equ	RSTDISBL	= 7	; External Reset disable
                 
                 ; EXTENDED fuse bits
                 .equ	SELFPRGEN	= 0	; Self-Programming Enable
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x0fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 512
                 .equ	RAMEND	= 0x025f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x01ff
                 .equ	EEPROMEND	= 0x01ff
                 .equ	EEADRBITS	= 9
                 #pragma AVRPART MEMORY PROG_FLASH 8192
                 #pragma AVRPART MEMORY EEPROM 512
                 #pragma AVRPART MEMORY INT_SRAM SIZE 512
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x0
                 .equ	NRWW_STOP_ADDR	= 0xfff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x0
                 .equ	PAGESIZE	= 32
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                 .equ	PCI0addr	= 0x0002	; Pin change Interrupt Request 0
                 .equ	OC1Aaddr	= 0x0003	; Timer/Counter1 Compare Match 1A
                 .equ	OVF1addr	= 0x0004	; Timer/Counter1 Overflow
                 .equ	OVF0addr	= 0x0005	; Timer/Counter0 Overflow
                 .equ	ERDYaddr	= 0x0006	; EEPROM Ready
                 .equ	ACIaddr	= 0x0007	; Analog comparator
                 .equ	ADCCaddr	= 0x0008	; ADC Conversion ready
                 .equ	OC1Baddr	= 0x0009	; Timer/Counter1 Compare Match B
                 .equ	OC0Aaddr	= 0x000a	; Timer/Counter0 Compare Match A
                 .equ	OC0Baddr	= 0x000b	; Timer/Counter0 Compare Match B
                 .equ	WDTaddr	= 0x000c	; Watchdog Time-out
                 .equ	USI_STARTaddr	= 0x000d	; USI START
                 .equ	USI_OVFaddr	= 0x000e	; USI Overflow
                 
                 .equ	INT_VECTORS_SIZE	= 15	; size in words
                 
                 #endif  /* _TN85DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                 ;*									 *
                 ;*				Generic AVR Bootloader			 *
                 ;*                                                                       *
                 ;*                      Author: Peter Dannegger                          *
                 ;*									 *
                 ;*************************************************************************
                 .include "fastload.h"
                 .list
                 	.org	BootStart
000f00 94f8      init:
000f01 e56f      	cli				; no interrupts allowed
000f02 bf6d      	ldi	a0, low (RamEnd)	; initialize stack
                 	out	SPL, a0
000f03 e062      .ifdef SPH
000f04 bf6e      	ldi	a0, high(RamEnd)
                 	out	SPH, a0
000f05 2422      .endif
000f06 2433      	clr	zerol			; for faster clear
                 	clr	zeroh
                 
                 .if WDTRIGGER
                 
000f07 95a8      	wdr
000f08 b561      	xin	a0, WDTCSR
000f09 6160      	ori	a0, 1<<WDCE				; change enable
000f0a e07f      	ldi	a1, 1<<WDE^1<<WDP2^1<<WDP1^1<<WDP0	; 2s
000f0b bd61      	xout	WDTCSR, a0
000f0c fd63      	sbrc	a0, WDE
000f0d bd71      	xout	WDTCSR, a1
                 ;-------------------------------------------------------------------------
                 
                 .endif
                 
000f0e 9ac0
000f0f 9ac1
000f10 9ab9      	IOPortInit
                 .if CRC
000f11 e021      	ldi	polynoml, 0x01
000f12 ea30      	ldi	polynomh, 0xA0
                 .endif
                 ;-------------------------------------------------------------------------
                 .include "abaud.inc"			; measure baudrate
                 
                 ;			automatic baud rate detection
                 ;-------------------------------------------------------------------------
                 ;
                 ; recognize any byte,
                 ; which contain 1 * bit time low, followed by 4 * bit times low
                 ;                      ____    __    __ __             ____
                 ;e.g. recognize 0x0D:      |__|  |__|  |  |__|__|__|__|
                 ;                          0  1  2  3     5           9
                 ;                                1*T               4*T
                 ;
                 .equ	TOLERANCE	= 3
                 .equ	MINTIME		= 90
                 ;
                 abaud:
000f13 e06d      	ldi	a0, byte3(BootDelay / 6)
                 _aba1:
000f14 01f1      	movw	zh:zl, zeroh:zerol	; cause first try invalid
                 _aba2:
000f15 01ef      	movw	yh:yl, zh:zl
000f16 01f1      	movw	zh:zl, zeroh:zerol	; z = 0x0000
                 _aba3:
000f17 9701      	sbiw	twh:twl, 1		;2
000f18 4060      	sbci	a0, 0			;1
000f19 99b0      	SKIP_RXD_0			;1	wait until RXD = 0
000f1a f7e1      	brne	_aba3			;2 = 6
000f1b f1d9      	breq	timeout
                 _aba4:
000f1c 9721      	sbiw	yh:yl, 1		;2
000f1d 9634      	adiw	zh:zl, 4		;2	count bit time
000f1e f1c0      	brcs	timeout			;1	time to long
000f1f 9bb0      	SKIP_RXD_1			;1 	wait until RXD = 1
000f20 cffb      	rjmp	_aba4			;2 = 8
                 ;------------------------------ correction for USB dongle !!! ------------
000f21 2e0f      	mov	r0, zh
                 _aba5:
000f22 95c5      	asr	yl			; shift signed !
000f23 9406      	lsr	r0
000f24 f7e9      	brne	_aba5
                 ;-------------------------------------------------------------------------
000f25 9723      	sbiw	yh:yl, TOLERANCE
000f26 9626      	adiw	yh:yl, 2 * TOLERANCE
000f27 f768      	brcc	_aba2			; outside tolerance
000f28 35ea      	cpi	zl, MINTIME
000f29 05f2      	cpc	zh, zerol
000f2a f350      	brcs	_aba2			; time to short
000f2b 97f7      	sbiw	zh:zl, 2*UartLoop-1	; rounding, -loop time
000f2c 95f6      	lsr	zh			; /2
000f2d 95e7      	ror	zl
000f2e 012f      	movw	baudh:baudl, zh:zl
                 ;inlined	ret
                 ;-------------------------------------------------------------------------
                 .include "password.inc"			; check password
                 
                 ;				Check password
                 ;-------------------------------------------------------------------------
000f2f e0ca      	ldi	yl, 10			; try it 10 times
                 .if FLASHEND > 0x7FFF
                 .endif
                 checkpwd:
000f30 ecec      	ldi	zl, low (2*Password)
000f31 e1ff      	ldi	zh, high(2*Password)
                 _cpw2:
000f32 9005      	XLPM	r0, z+
000f33 2000      	tst	r0
000f34 f031      	breq	_cpw3			; end if zero byte
000f35 d07b      	rcall	getchar
000f36 1606      	cp	r0, a0
000f37 f3d1      	breq	_cpw2			; compare next byte
000f38 95ca      	dec	yl			; count down wrong compares
000f39 f0e9      	breq	timeout
000f3a cff5      	rjmp	checkpwd		; try again
                 _cpw3:
                 ;-------------------------------------------------------------------------
                 ;-------------------------------------------------------------------------
                 connected:
000f3b ea66      	ldi	a0, CONNECT		; password recognized
                 .if ONEWIRE
                 .else
000f3c d08e      	rcall	putchar
                 .endif
000f3d d073      	rcall	getchar
000f3e f7e1      	brne	connected		; until COMMAND received
                 ;-------------------------------------------------------------------------
                 .include "command.inc"			; execute commands
                 
                 ;				Receive commands
                 ;-------------------------------------------------------------------------
                 ;00	get bootloader revision
                 ;01	get buffer size
                 ;02	get target signature
                 ;03	get user flash size
                 ;04	program flash
                 ;05	start application
                 ;06	check crc
                 ;07	verify flash
                 ;-------------------------------------------------------------------------
                 main_ok:
000f3f ea6a      	ldi	a0, SUCCESS
                 _cex1:
000f40 d08a      	rcall	putchar
                 _cex2:
000f41 d06f      	rcall	getchar
000f42 f7f1      	brne	_cex2			; ignore until COMMAND
                 _cex3:
000f43 d06d      	rcall	getchar
000f44 f3f1      	breq	_cex3			; ignore further COMMAND
                 .if FLASHEND > 0x7FFF
                 .endif
000f45 01f1      	movw	zh:zl, zeroh:zerol      ; Z = 0x0000,
000f46 94e8      	clt				; T = 0 (for program, verify)
000f47 3064      	cpi	a0, 4
000f48 f088      	brcs	SendMessage		; command 0 ... 3
000f49 f159      	breq	program			; command 4
000f4a 3065      	cpi	a0, 5
000f4b f059      	breq	timeout			; command 5
000f4c 3067      	cpi	a0, 7
                 .if VERIFY
000f4d f101      	breq	VerifyFlash		; command 7
                 .endif
000f4e ea67      	ldi	a0, BADCOMMAND
                 ;-------------------------------------------------------------------------
                 .if CRC
000f4f f780      	brcc	_cex1			; command >7
                 ;-------------------------------------------------------------------------
                 CheckCRC:				; command 6
000f50 d060      	rcall	getchar			; read CRC low
000f51 d05f      	rcall	getchar			; read CRC high
000f52 2867      	or	crcl, crch		; now CRC = 0x0000 ?
000f53 f359      	breq	main_ok			; yes
000f54 0131      	movw	crch:crcl, zeroh:zerol	; clear CRC
                 .else
                 .endif
                 ;-------------------------------------------------------------------------
                 main_error:
000f55 ea6b      	ldi	a0, FAIL
000f56 cfe9      	rjmp	_cex1
                 ;-------------------------------------------------------------------------
                 timeout:				; command 5
000f57 ba27      	out	STX_DDR, zerol
000f58 ba28      	out	STX_PORT, zerol
                 .if SRX_PORT != STX_PORT
                 .endif
                 .if FlashEnd > 0x0FFF
                 .else
000f59 cfa5      	rjmp	Application		; run application
                 .endif
                 ;-------------------------------------------------------------------------
                 .include "message.inc"			; command 0 ... 3
                 
                 ;				Send Messages
                 ;-------------------------------------------------------------------------
                 ;input: a0 = number of message 0 .. 3
                 ;
                 SendMessage:
                 .if FLASHEND > 0x7FFF
                 .endif
000f5a ede2      	ldi	zl, low (2*Messages)
000f5b e1ff      	ldi	zh, high(2*Messages)
000f5c e0c0      	ldi	yl, 0
                 _sme1:
000f5d 0fec      	add	zl, yl			; add offset to next message
000f5e 1df2      	adc	zh, zerol
000f5f 91c4      	XLPM	yl, z
000f60 5061      	subi	a0, 1			; count down until message found
000f61 f7d8      	brcc	_sme1
000f62 ea68      	ldi	a0, ANSWER		; first byte of message
                 _sme2:
000f63 d067      	rcall	putchar
000f64 9165      	XLPM	a0, z+
000f65 50c1      	subi	yl, 1
000f66 f7e0      	brcc	_sme2
000f67 cfd7      	rjmp	main_ok
                 ;-------------------------------------------------------------------------
                 ;-------------------------------------------------------------------------
                 .if VERIFY
                 .include "verify.inc"			; command 7
                 
                 ;		 		Verify User Flash
                 ;-------------------------------------------------------------------------
                 ;
                 _ver1:
                 .if FLASHEND > 0x7FFF
                 .else
000f68 9005      	lpm	r0, z+
                 .endif
                 .ifndef FirstBootStart
000f69 30e3      	cpi	zl, 3
000f6a 05f2      	cpc	zh, zerol
000f6b f010      	brcs	VerifyFlash		; exclude jump to bootloader
                 .endif
000f6c 1206      	cpse	r0, a0
000f6d 9468      	set
                 VerifyFlash:
000f6e d042      	rcall	getchar
000f6f f7c1      	brne	_ver1			; not COMMAND ?
000f70 d040      	rcall	getchar
000f71 5860      	subi	a0, ESC_SHIFT
000f72 f7a9      	brne	_ver1			; COMMMAND + not COMMAND = End
000f73 f30e      	brts	main_error		; error, Flash not equal
000f74 cfca      	rjmp	main_ok
                 ;-------------------------------------------------------------------------
                 .endif
                 ;-------------------------------------------------------------------------
                 .ifdef FirstBootStart
                 .else
                 .include "progtiny.inc"		; tiny, mega without RWW section
                 
                 ;		 		Program User Flash
                 ;-------------------------------------------------------------------------
                 ;
                 Program:
000f75 e6a0      	ldi	xl, low (ProgBuff)
000f76 e0b0      	ldi	xh, high(ProgBuff)
000f77 01ed      	movw	yh:yl, xh:xl
000f78 f0e6      	brts	_pro5
                 ;---------------------- Receive data for one Page ------------------------
                 _pro1:
000f79 d037      	rcall	getchar
000f7a f429      	brne	_pro2
000f7b d035      	rcall	getchar
000f7c 5860      	subi	a0, ESC_SHIFT
000f7d 9468      	set				; end mark received set
000f7e f021      	breq	_pro3
000f7f 94e8      	clt
                 _pro2:
000f80 936d      	st	x+, a0
000f81 3aa0      	cpi	xl, low(ProgBuffEnd)	; since buffer size below 256
000f82 f7b1      	brne	_pro1
                 ;-------------------------------------------------------------------------
                 _pro3:
000f83 9630      	adiw	zh:zl, 0
000f84 f481      	brne	_pro5
                 ;------------------------------ Insert rjmp to boot loader ---------------
000f85 8108      	ld	appl, y
000f86 8119      	ldd	apph, y+1
000f87 5f0f      	subi	appl, low (BootStart - 0x1001)	; new application jump
000f88 4f1e      	sbci	apph, high(BootStart - 0x1001)
000f89 ef6f      	ldi	a0, low (BootStart-1)
000f8a ec7e      	ldi	a1, high(BootStart-1 + 0xC000)  ; = RJMP
000f8b 8368      	st	y, a0
000f8c 8379      	std	y+1, a1				; replace by bootloader jump
                 ;-------------------------------------------------------------------------
                 ;               Erase application Flash backward (avoid lock out)
                 ;-------------------------------------------------------------------------
000f8d e0e0      	ldi     zl, low (2*BootStart)
000f8e e1fe      	ldi     zh, high(2*BootStart)
                 _pro4:
                 .if PageSize < 32
                 .else
000f8f 54e0      	subi    zl, low (2*PageSize)
000f90 40f0      	sbci    zh, high(2*PageSize)
                 .endif
000f91 e063      	ldi	a0, 1<<PGERS^1<<SPMEN
000f92 bf67      	out     SPMCSR, a0
000f93 95e8      	SPM                             ; CPU halted until erase done
000f94 f7d1      	brne    _pro4			; until Z = 0x0000
                 ;-------------------------------------------------------------------------
                 _pro5:
000f95 f416      	brtc	_pro6
000f96 af0e      	std	y+2*PageSize-2, appl
000f97 af1f      	std	y+2*PageSize-1, apph
                 ;---------------------- Fill page buffer ---------------------------------
                 _pro6:
000f98 9009      	ld	r0, y+
000f99 9019      	ld	r1, y+
000f9a e061      	ldi	a0, 1<<SPMEN		; fill buffer command
000f9b bf67      	out	SPMCSR, a0
000f9c 95e8      	SPM
000f9d 9632      	adiw	zh:zl, 2
000f9e 3ac0      	cpi	yl, low(ProgBuffEnd)
000f9f f7c1      	brne	_pro6
                 .if PageSize < 32
                 .else
000fa0 54e0      	subi	zl, low (PageSize * 2)
000fa1 40f0      	sbci	zh, high(PageSize * 2)
                 .endif
                 ;---------------------- Program page -------------------------------------
000fa2 e065      	ldi	a0, 1<<PGWRT^1<<SPMEN	; write page command
000fa3 bf67      	out	SPMCSR, a0
000fa4 95e8      	SPM
                 ;---------------------- Next Page ----------------------------------------
                 .if PageSize < 32
                 .else
000fa5 5ce0      	subi	zl, low (-PageSize * 2)
000fa6 4fff      	sbci	zh, high(-PageSize * 2)	; point to next page
                 .endif
000fa7 f016      	brts	_pro8
000fa8 ea69      	ldi	a0, CONTINUE
000fa9 d021      	rcall	putchar
                 _pro8:
000faa 30e0      	cpi	zl, low( 2*BootStart)
000fab e16e      	ldi	a0, high(2*BootStart)
000fac 07f6      	cpc	zh, a0                  ; last page reached ?
000fad f238      	brcs	Program
000fae f00e      	brts	_pro9
000faf cfa5      	rjmp	main_error		; error, size exceeded
                 _pro9:
000fb0 cf8e      	rjmp	main_ok
                 ;-------------------------------------------------------------------------
                 .endif
                 ;-------------------------------------------------------------------------
                 .include "uart.inc"			; UART subroutines
                 
                 ;				Receive Byte
                 ;-------------------------------------------------------------------------
                 ;output: a0 = byte
                 ;used: a1
                 ;
                 getchar:
                 .if WDTRIGGER
000fb1 95a8      	wdr	
                 .endif
000fb2 9bb0      	SKIP_RXD_1			; wait for RXD = 1
000fb3 cffd      	rjmp	getchar
                 _rx1:
000fb4 99b0      	SKIP_RXD_0			; wait for RXD = 0 (start bit)
000fb5 cffe      	rjmp	_rx1
000fb6 e078      	ldi	a1, 8
000fb7 01c2      	movw	twh:twl, baudh:baudl
000fb8 9596      	lsr	twh
000fb9 9587      	ror	twl
000fba d023      	rcall	wait_time		; middle of start bit
                 _rx2:
000fbb d021      	rcall	wait_bit_time		;14 + tw
000fbc 9566      	lsr	a0			;1
000fbd 99b0      	SKIP_RXD_0			;1/2
000fbe 6860      	ori	a0, 0x80		;1
                 .if CRC
                 ;------------------------------ CRC --------------------------------------
000fbf fd67      	sbrc	a0, 7			;1
000fc0 2662      	eor	crcl, polynoml		;1 crcl.0 ^= a0.7
000fc1 9476      	lsr	crch			;1
000fc2 9467      	ror	crcl			;1
000fc3 f408      	brcc	_rx5			;1
000fc4 2662      	eor	crcl, polynoml		;1 ^0x01
                 _rx5:
000fc5 f408      	brcc	_rx6			;1
000fc6 2673      	eor	crch, polynomh		;1 ^0xA0
                 _rx6:
                 ;-------------------------------------------------------------------------
                 .else
                 .endif
000fc7 957a      	dec	a1			;1
000fc8 f791      	brne	_rx2			;2 = 24 + tw
000fc9 3a65      	cpi	a0, COMMAND		; needed several times
000fca 9508      	ret
                 ;-------------------------------------------------------------------------
                 ;				transmit byte
                 ;-------------------------------------------------------------------------
                 ;input: a0 = byte
                 ;used: a1
                 ;
                 putchar:
000fcb d011      	rcall	wait_bit_time
000fcc 98c1      	TXD_0
                 .if ONEWIRE
                 .else
000fcd 9174      	lpm	a1, z			;3
                 .endif
000fce e079      	ldi	a1, 9			;1
000fcf 9560      	com	a0			;1 = 5
                 _tx3:
                 .if CRC
000fd0 c000      	rjmp	pc+1			;2
000fd1 c000      	rjmp	pc+1			;2
                 .endif
000fd2 d00a      	rcall	wait_bit_time		;14 + tw
000fd3 9566      	lsr	a0			;1
000fd4 f418      	brcc	_tx4			;1/2
000fd5 0000      	nop				;1
000fd6 98c1      	TXD_0				;2
000fd7 c002      	rjmp	_tx5			;2
                 _tx4:
000fd8 9ac1      	TXD_1				;2
000fd9 c000      	rjmp	_tx5			;2
                 _tx5:
000fda 957a      	dec	a1			;1
000fdb f7a1      	brne	_tx3			;2 = 24 + tw
000fdc 9508      	ret
                 ;-------------------------------------------------------------------------
                 ;	Wait 14 cycle + tw
                 ;
                 wait_bit_time:
000fdd 01c2      	movw	twh:twl, baudh:baudl	;1
                 wait_time:
000fde 9704      	sbiw	twh:twl, 4		;2
000fdf f7f0      	brcc	wait_time		;2/1
000fe0 3f8d      	cpi	twl, 0xFD		;1
000fe1 f018      	brcs	_wt1			;2/1 (2)
000fe2 f011      	breq	_wt1			;2/1 (3)
000fe3 3f8f      	cpi	twl, 0xFF		;1
000fe4 f001      	breq	_wt1			;2/1 (4/5)
                 _wt1:
000fe5 9508      	ret				;4 + 3 (rcall) = 14
                 ;-------------------------------------------------------------------------
                 ;-------------------------------------------------------------------------
                 Password:
000fe6 6550
000fe7 6164
000fe8 0000      	.db	"Peda", 0, 0		; 'a' was recognized by ABAUD
                 .list
                 Messages:
                 	.db \
000fe9 0203      	3, high(Version), low(Version), \
000fea 0301      	3, high(2*BufferSize), low(2*BufferSize), \
000feb 4000
000fec 1e04      	4, SIGNATURE_000, SIGNATURE_001, SIGNATURE_002, \
000fed 0b93
000fee 0004
000fef fe1d      	4, byte3(UserFlash), byte2(UserFlash), byte1(UserFlash)
                 ;-------------------------------------------------------------------------
                 .if APICALL
                 .else
                 	.org	Flashend
000fff 9508      	ret
                 .endif
                 ;-------------------------------------------------------------------------
                 ;-------------------------------------------------------------------------


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATtiny85 register use summary:
r0 :   8 r1 :   1 r2 :  10 r3 :   5 r4 :   3 r5 :   3 r6 :   5 r7 :   4 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16:   3 r17:   3 r18:   3 r19:   2 r20:   0 r21:   0 r22:  42 r23:   9 
r24:   7 r25:   5 r26:   3 r27:   2 r28:  13 r29:   5 r30:  20 r31:  21 
x  :   1 y  :   8 z  :   5 
Registers used: 25 out of 35 (71.4%)

ATtiny85 instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   1 adiw  :   4 and   :   0 
andi  :   0 asr   :   1 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   8 brcs  :   6 break :   0 breq  :  12 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  13 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   4 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   2 cbr   :   0 clc   :   0 
clh   :   0 cli   :   1 cln   :   0 clr   :   2 cls   :   0 clt   :   2 
clv   :   0 clz   :   0 com   :   1 cp    :   1 cpc   :   3 cpi   :  11 
cpse  :   1 dec   :   3 eor   :   3 icall :   0 ijmp  :   0 in    :   1 
inc   :   0 ld    :   3 ldd   :   1 ldi   :  30 lds   :   0 lpm   :   7 
lsl   :   0 lsr   :   6 mov   :   1 movw  :   9 neg   :   0 nop   :   1 
or    :   1 ori   :   2 out   :   9 pop   :   0 push  :   0 rcall :  18 
ret   :   4 reti  :   0 rjmp  :  14 rol   :   0 ror   :   3 sbc   :   0 
sbci  :   5 sbi   :   4 sbic  :   3 sbis  :   2 sbiw  :   5 sbr   :   0 
sbrc  :   2 sbrs  :   0 sec   :   0 seh   :   0 sei   :   0 sen   :   0 
ser   :   0 ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   0 
spm   :   6 st    :   2 std   :   3 sts   :   0 sub   :   0 subi  :   8 
swap  :   0 tst   :   1 wdr   :   2 
Instructions used: 50 out of 105 (47.6%)

ATtiny85 memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x001e00 0x002000    462     20    482    8192   5.9%
[.dseg] 0x000060 0x0000a0      0     64     64     512  12.5%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
