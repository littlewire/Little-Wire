<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Little-Wire: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Little-Wire
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Little Wire</title>

</head>
<body>
<p><img src="https://github.com/kehribar/Little-Wire/raw/master/v1.1/Little-Wire_beta.jpg" alt="Little wire beta in action" /></p>

<h1>Little Wire</h1>

<p>Little Wire is multi-featured USB controlled open source hardware tool packed in a minimal form factor designed by ihsan Kehribar. This documentation explains the features of the Little Wire via computer inteface library written in C language. Details of the library can be found in the <code>littleWire.h</code> header file.</p>

<p>There are also official C++, C# and Processing libraries for interfacing with the current or previous firmware versions of the Little Wire. At some level, maintaining more than one language become a problem; therefore currently the C language library will be the only official and supported interface library. On the other hand there is a good supported Ruby library exists for some features of the Little Wire. Users can take a look at it.</p>

<h2>Basic features</h2>

<h3>AVR Programming</h3>

<p>Little Wire is an <strong>usbtinyisp</strong> compatible AVR programmer, right out of the box. 2x3 pinheader at the Little Wire is standard AVR-ISP header compatible. Individual pin mapping for this mode is:</p>

<pre><code>PIN1 -&gt; MISO
PIN2 -&gt; SCK
PIN3 -&gt; RESET
PIN4 -&gt; MOSI
</code></pre>

<h3>Digital I/O</h3>

<p>Little Wire has 4 available GPIO pins. Any of the pins can be used for writing/reading. Logic level is +5 volts. Don’t apply more than +5 volts to any GPIO pin.</p>

<ul>
<li><p>Logic output</p>

<pre><code>  /* First, configure pin as output */
  pinMode(lw,PIN1,OUTPUT);

  /* Set the logic level of the pin to a desired level */
  digitalWrite(lw,PIN1,HIGH);
</code></pre>

<p>  For a complete example, refer to the <code>blink.c</code> example file.</p></li>
<li><p>Logic input</p>

<pre><code>  /* First configure pin as input */
  pinMode(lw,PIN2,INPUT);

  /* Optionally, enable or disable the internal pullup resistor */
  internalPullup(lw,PIN2,ENABLE);

  /* Read the level of the digital pin */
  if(digitalRead(lw,PIN2) == LOW)
  {
      /* do something ... */
  }       
</code></pre>

<p>  For a complete example, refer to the <code>button.c</code> example file.</p></li>
</ul>


<h3>ADC</h3>

<p>Little Wire has 10 bit ADC. Reference voltage is selectable. PIN2 and PIN3 are available for ADC feature. Reading analog voltage from PIN3 is noisy; use it at your own risk. PIN2 is suggested for generic ADC usage.</p>

<p>Moreover, the Little Wire supports reading the internal temperature sensor of the Attiny85. You can refer to Attiny85 datasheet for the details of this internal sensor.</p>

<ul>
<li><p>Analog read</p>

<pre><code>  /* Select ADC reference */
  /* Those definetly needs calibration for precision measurements. */
  analog_init(lw,VREF_VCC);
  // analog_init(lw,VREF_1100mV);
  // analog_init(lw,VREF_2560mV;  

  /* Read 10 bit unsigned ADC value */
  adcValue = analogRead(lw, ADC_PIN2);
</code></pre>

<p>  For a complete example, refer to the <code>adc.c</code> example file.</p></li>
</ul>


<h3>PWM</h3>

<h4>Hardware PWM</h4>

<p>Little Wire can generate hardware PWM signals from PIN1 and PIN4. PWM frequency is adjustabla via prescaler setting. Valid prescaler values are <em>1, 8, 64, 256</em> and <em>1024</em>. Higher the prescaler value, slower the PWM freuqency.</p>

<ul>
<li><p>Hardware PWM</p>

<pre><code>  /* Init the PWM module */
  pwm_init(lw);

  /* Set the maximum PWM frequency */
  pwm_updatePrescaler(lw,1);  

  /* Update the PWM values when needed */
  pwm_updateCompare(lw,val1,val2);
</code></pre>

<p>  For a complete example, refer to the <code>hardwarePWM.c</code> example file.</p></li>
</ul>


<h5>Servo driving</h5>

<p>Servo driving is a subset library for the hardware PWM module. It adjusts the PWM output signals for servo diriving.</p>

<ul>
<li><p>Servo driving</p>

<pre><code>  /* Init the servo specialized hardware PWM module */
  servo_init(lw);

  /* Set two servo channels to the opposite positions */
  /* Location value is in degrees */
  servo_updateLocation(lw,currentLocation,(180 - currentLocation));
</code></pre>

<p>  For a complete example, refer to the <code>servo.c</code> example file.</p></li>
</ul>


<h4>Software PWM</h4>

<p>Little Wire can generate software PWM signals from PIN1, PIN2 and PIN4. Usefull for driving an RGB LED.</p>

<ul>
<li><p>RGB LED driving</p>

<pre><code>   /* First, enable the software PWM module */
   softPWM_state(lw,ENABLE);

   /* Update the PWM values when needed ... */
   /* r,g and b are the three PWM values for an RGB LED */
   softPWM_write(lw,r,g,b);
</code></pre>

<p>  For a complete example, refer to the <code>softPWM.c</code> example file.</p></li>
</ul>


<h3>SPI</h3>

<p>Little Wire can act like an SPI master device. Pin mapping for SPI mode is as follows:</p>

<pre><code>PIN1 -&gt; Data out
PIN2 -&gt; Clock
PIN3 -&gt; Chip select
PIN4 -&gt; Data in
</code></pre>

<ul>
<li><p>Communication with manual chip select</p>

<pre><code>  /* Set the chip select pin as output. */
  pinMode(lw,PIN3,OUTPUT);

  /* Set the value of the chip select pin high initially */
  digitalWrite(lw,PIN3,HIGH);

  /* Change this according to your device. If your device doesn't respond, try to increase the delay */
  /* This is the maximum speed. */
  spi_updateDelay(lw,0); 

  /* Set the chip select pin low before sending the data */
  digitalWrite(lw,PIN3,LOW);

  /* Fill the SPI send buffer */
  sendBuffer[0] = 0;
  sendBuffer[1] = 1;
  sendBuffer[2] = 2;
  sendBuffer[3] = 3;                      

  /* Send the initial bytes ... Maximum length for SPI message buffer is 4 */
  spi_sendMessage(lw,sendBuffer,receiveBuffer,4,MANUAL_CS);

  /* Fill the SPI send buffer */
  sendBuffer[0] = 4;
  sendBuffer[1] = 5;
  sendBuffer[2] = 6;                      

  /* Send the rest of the bytes ... This time we set the length as 3 */
  spi_sendMessage(lw,sendBuffer,receiveBuffer,3,MANUAL_CS);

  /* Set the chip select pin high again */
  digitalWrite(lw,PIN3,HIGH);
</code></pre></li>
<li><p>Communication with automatic chip select</p>

<pre><code>  /* Set the chip select pin as output. */
  pinMode(lw,PIN3,OUTPUT);

  /* Set the value of the chip select pin high initially */
  digitalWrite(lw,PIN3,HIGH);

  /* Change this according to your device. If your device doesn't respond, try to increase the delay */
  /* This is the maximum speed. */
  spi_updateDelay(lw,0); 

  /* Fill the SPI send buffer */
  sendBuffer[0] = 1;
  sendBuffer[1] = 2;
  sendBuffer[2] = 3;                      

  /* Send the bytes. Chip select pin levels are automatically handled by the hardware */
  spi_sendMessage(lw,sendBuffer,receiveBuffer,3,AUTO_CS);
</code></pre>

<p>  For a complete example, refer to the <code>spi_LTC1448.c</code> example file.</p></li>
</ul>


<h3>I2C</h3>

<p>Little Wire can act like an I2C master device. Pin mapping for I2C mode is as follows:</p>

<pre><code>PIN2 -&gt; SCL
PIN4 -&gt; SDA
</code></pre>

<ul>
<li><p>I2C BlinkM driving</p>

<pre><code>  /* Init i2c module */
  i2c_init(lw);

  /* Set the i2c signal delay according to your device. */
  i2c_updateDelay(lw,10);

  /* Initiate the communication in WRITE mode */
  i2c_start(lw,7bit_address,WRITE);

  /* Fill the i2c send buffer */  
  /* BlinkM 'Go to custom HSV color' command */
  myBuffer[0] = 'h';
  myBuffer[1] = 123;
  myBuffer[2] = 215;
  myBuffer[3] = 155;      

  /* Write 4 bytes to the slave device. Maximum length is 4 */
  i2c_write(lw,myBuffer,4,END_WITH_STOP);

  /* Wait a little ... */
  delay(10);

  /* Initiate the communication in WRITE mode */
  i2c_start(lw,7bit_address,WRITE);   

  /* Fill the i2c buffer */
  /* BlinkM 'Get the current RGB color' command */
  myBuffer[0] = 'g'; 

  /* Write 1 byte to the slave device */
  i2c_write(lw,myBuffer,1,END_WITH_STOP);

  /* Wait a little ... */
  delay(10);

  /* Initiate the communication in READ mode */
  i2c_start(lw,7bit_address,WRITE);

  /* Read 3 bytes from slave ... */ 
  i2c_read(lw,myBuffer,3,END_WITH_STOP);
</code></pre>

<p>  For a complete example, refer to the <code>i2c_blinkM.c</code> example file.</p></li>
<li><p>Address search</p>

<pre><code>  /* Init i2c module */
  i2c_init(lw);

  /* Set the i2c signal delay according to your device. */
  i2c_updateDelay(lw,10);

  printf("&gt; Address search ... \n");

  /* Search for all possible address values */
  for(i=0;i&lt;128;i++)
  {
      /* Try to initiate communication */
      rc = i2c_start(lw,i,WRITE); 

      /* Return value is 1 if a valid ACK is received */
      if(rc == 1)
      {
          printf("&gt; Found device at %3d\n",i);
      }
  }
</code></pre>

<p>  For a complete example, refer to the <code>i2c_blinkM.c</code> example file.</p></li>
</ul>


<h3>Onewire</h3>

<p>Little Wire can act like an 1-wire master device. Pin mapping for 1-wire mode is as follows:</p>

<pre><code>PIN2 -&gt; Data
</code></pre>

<ul>
<li><p>DS1820 type digital sensor</p>

<pre><code>  // send reset signal and read the presence value 
  // if this returns zero, sensor is unplugged 
  if(!onewire_resetPulse(lw))         
  {
      printf("&gt; Sensor is unplugged!\n");
      return 0;
  }

  // onewire_writeByte(0xCC); /* SKIP ROM command */
  onewire_writeByte(lw,0x55); /* MATCH ROM command *      
  onewire_writeByte(lw,ROM_NO[0]); /* Address begins */
  onewire_writeByte(lw,ROM_NO[1]);
  onewire_writeByte(lw,ROM_NO[2]);
  onewire_writeByte(lw,ROM_NO[3]);
  onewire_writeByte(lw,ROM_NO[4]);
  onewire_writeByte(lw,ROM_NO[5]);
  onewire_writeByte(lw,ROM_NO[6]);
  onewire_writeByte(lw,ROM_NO[7]); /* Address ends */ 
  onewire_writeByte(lw,0x44); /* CONVERT T command */

  // wait for conversion - this is important, if you allways get 85 deg. C, increase tis value 
  delay(650);

  // send reset signal and read the presence value
  if(!onewire_resetPulse(lw)) // if this returns zero, sensor is unplugged        
  {
      printf("&gt; Sensor is unplugged!\n");
      return 0;
  }

  // onewire_writeByte(0xCC); /* SKIP ROM command */
  onewire_writeByte(lw,0x55); /* MATCH ROM command */     
  onewire_writeByte(lw,ROM_NO[0]); /* Address begins */
  onewire_writeByte(lw,ROM_NO[1]);
  onewire_writeByte(lw,ROM_NO[2]);
  onewire_writeByte(lw,ROM_NO[3]);
  onewire_writeByte(lw,ROM_NO[4]);
  onewire_writeByte(lw,ROM_NO[5]);
  onewire_writeByte(lw,ROM_NO[6]);
  onewire_writeByte(lw,ROM_NO[7]); /* Address ends */ 
  onewire_writeByte(lw,0xBE); /* Read register (scratchpad) command */

  for(i=0;i&lt;9;i++) //read 9 bytes from SCRATCHPAD
  {   
      scratch = onewire_readByte(lw);

      if (i == 0) // LSB temperature register byte (0)
              templow = scratch;
      if (i == 1) // MSB temperature register byte (1)
              temphigh = scratch;
  }

  tempdecimal = 0;

  if ((templow &amp; 0x01) == 0x01)
  {
      tempdecimal += 625; 
  }

  if ((templow &amp; 0x02) == 0x02)
  {
      tempdecimal += 1250;    
  }

  if ((templow &amp; 0x04) == 0x04)
  {
      tempdecimal += 2500;    
  }

  if ((templow &amp; 0x08) == 0x08)
  {
      tempdecimal += 5000;    
  }                       

  tempdecimal /= 10;

  printf("&gt; TEMP %c%d.%d deg. C\n", ((temphigh &amp; 0x80) == 0x80) ? '-' : ' ', ((templow &amp; 0xf0) &gt;&gt; 4) | ((temphigh &amp; 0x07) &lt;&lt; 4), tempdecimal);
</code></pre></li>
<li><p>Address search</p>

<pre><code>  printf("&gt; Address search ... \n");

  if(onewire_firstAddress(lw))
  {
      printf("&gt; Addr#%d:  %X\t",i,ROM_NO[0]);
      for(t=0;t&lt;7;t++)
          printf("%X\t",ROM_NO[t+1]);         
      printf("\n");
      i = 1;
  }

  while(onewire_nextAddress(lw))
  {
      printf("&gt; Addr#%d:  %X\t",i,ROM_NO[0]);
      for(t=0;t&lt;7;t++)
          printf("%X\t",ROM_NO[t+1]);         
      printf("\n");
      i++;
  }

  if(i &gt; 0)
  {
      printf("&gt; End of search with %d onewire device(s) found\r\n",i);
  }   
  else
  {
      printf("&gt; No onewire device has been found!\n");
      return 0;
  }
</code></pre>

<p>  For a complete example, refer to the <code>onewire.c</code> example file.</p></li>
</ul>


<h2>Advanced features</h2>

<pre><code>To be continued …
</code></pre>

<h2>Reference projects</h2>

<ul>
<li>This project is proudly and heavily based on:

<ul>
<li>Original usbtiny project
  http://www.xs4all.nl/~dicks/avr/usbtiny/</li>
<li>Ladyada version of usbtiny
  http://www.ladyada.net/make/usbtinyisp/</li>
<li>simpleavr's implementation of usbTiny on attiny45 microcontroller
  http://www.simpleavr.com/avr/vusbtiny</li>
<li>Libusb library for C , C++ interface
  http://www.libusb.org/</li>
<li>Libusbdotnet library for C# inteface
  http://libusbdotnet.sourceforge.net/V2/Index.html</li>
<li>Libusbjava library for Processing interface
  http://libusbjava.sourceforge.net</li>
<li>"fast tiny &amp; mega UART bootloader" project from AVR freaks
  http://tinyurl.com/fastTinyAndMega-UARTbootloader</li>
<li>Micronucleus bootloader: https://github.com/Bluebie/micronucleus-t85</li>
</ul>
</li>
</ul>


<h2>Please note:</h2>

<pre><code>Do not use the Adafruit USB VID/PID without written permission from Adafruit Industries, LLC and 
Limor "Ladyada" Fried (support@adafruit.com). Permission is granted for littlewire, Ihsan Kehribar
and Seeed Studio by Adafruit Industries, LLC to use the Adafruit USB VID/PID for littlewire 
(SKU:AVR06071P)
</code></pre>
</body>
</html>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu May 2 2013 01:43:07 for Little-Wire by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
